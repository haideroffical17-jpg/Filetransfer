<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Peer File Share — Simple WebRTC (Copy/Paste SDP)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:18px;background:#f6f7fb;color:#111}
  h1{font-size:20px;margin:0 0 8px}
  .card{background:#fff;padding:14px;border-radius:10px;box-shadow:0 6px 18px rgba(20,30,50,0.06);margin-bottom:12px}
  label{display:block;margin:10px 0 6px;font-weight:600}
  textarea{width:100%;height:120px;padding:8px;border-radius:6px;border:1px solid #ddd;font-family:monospace}
  button{padding:8px 12px;border-radius:8px;border:0;background:#2563eb;color:#fff;font-weight:600;cursor:pointer}
  button.gray{background:#6b7280}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  progress{width:100%}
  #log{white-space:pre-wrap;font-family:monospace;background:#f3f4f6;padding:8px;border-radius:6px;border:1px dashed #e5e7eb;height:120px;overflow:auto}
  small{color:#6b7280}
  .peer-info{font-size:13px;color:#374151;margin-top:6px}
</style>
</head>
<body>
  <h1>Peer File Share — WebRTC (manual signaling)</h1>

  <div class="card">
    <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
      <div><strong>Status:</strong> <span id="status">idle</span></div>
      <div class="peer-info">Note: Use modern browser. Serve via HTTPS or localhost.</div>
    </div>

    <label>Choose file to send</label>
    <input id="fileInput" type="file" />

    <label>Chunk size (bytes)</label>
    <input id="chunkSize" type="number" value="16384" min="1024" style="width:140px"/>

    <div style="margin-top:10px" class="row">
      <button id="createOfferBtn">Create Offer (I'm sender)</button>
      <button id="acceptOfferBtn" class="gray">Accept Offer (I'm receiver)</button>
      <button id="closeBtn" class="gray">Close / Reset</button>
    </div>

    <label style="margin-top:12px">Local SDP (copy & send to peer)</label>
    <textarea id="localSDP" readonly></textarea>

    <label>Remote SDP (paste peer's SDP here)</label>
    <textarea id="remoteSDP" placeholder="Paste remote SDP here"></textarea>

    <div style="margin-top:8px" class="row">
      <button id="applyRemoteBtn">Apply Remote SDP</button>
      <button id="copyLocalBtn" class="gray">Copy Local SDP</button>
    </div>
  </div>

  <div class="card">
    <h2 style="margin-top:0">Transfer</h2>
    <div><strong>Peer connection:</strong> <span id="pcState">—</span></div>
    <div style="margin-top:8px">
      <label>Send progress</label>
      <progress id="sendProgress" max="100" value="0"></progress>
      <div id="sendInfo" style="font-size:13px;color:#374151"></div>
    </div>

    <div style="margin-top:8px">
      <label>Receive progress</label>
      <progress id="recvProgress" max="100" value="0"></progress>
      <div id="recvInfo" style="font-size:13px;color:#374151"></div>
    </div>

    <div style="margin-top:8px">
      <label>Log</label>
      <div id="log"></div>
    </div>
  </div>

<script>
/*
  Simple peer-to-peer file transfer using WebRTC DataChannel.
  Signaling is manual: generate offer -> copy local SDP -> paste to remote -> remote generates answer -> copy answer -> paste back.
  Works without a server. Use HTTPS or localhost.
*/

const logEl = id => document.getElementById(id);
const fileInput = document.getElementById('fileInput');
const createOfferBtn = document.getElementById('createOfferBtn');
const acceptOfferBtn = document.getElementById('acceptOfferBtn');
const localSDP = document.getElementById('localSDP');
const remoteSDP = document.getElementById('remoteSDP');
const applyRemoteBtn = document.getElementById('applyRemoteBtn');
const copyLocalBtn = document.getElementById('copyLocalBtn');
const closeBtn = document.getElementById('closeBtn');
const statusSpan = document.getElementById('status');
const pcState = document.getElementById('pcState');
const sendProgress = document.getElementById('sendProgress');
const recvProgress = document.getElementById('recvProgress');
const sendInfo = document.getElementById('sendInfo');
const recvInfo = document.getElementById('recvInfo');
const chunkSizeInput = document.getElementById('chunkSize');
const logBox = document.getElementById('log');

let pc = null;
let dataChannel = null;
let receiveBuffer = [];
let receivedSize = 0;
let expectedFileSize = 0;
let expectedFileName = '';
let isSender = false;

function log(...args) {
  const t = new Date().toLocaleTimeString();
  logBox.textContent += `[${t}] ${args.join(' ')}\n`;
  logBox.scrollTop = logBox.scrollHeight;
}

function reset() {
  if (pc) {
    try { pc.close(); } catch(e){}
  }
  pc = null;
  dataChannel = null;
  receiveBuffer = [];
  receivedSize = 0;
  expectedFileSize = 0;
  expectedFileName = '';
  localSDP.value = '';
  remoteSDP.value = '';
  statusSpan.textContent = 'idle';
  pcState.textContent = '—';
  sendProgress.value = 0; recvProgress.value = 0;
  sendInfo.textContent = ''; recvInfo.textContent = '';
  log('Reset connection.');
}

closeBtn.addEventListener('click', reset);
copyLocalBtn.addEventListener('click', async ()=> {
  try {
    await navigator.clipboard.writeText(localSDP.value);
    log('Local SDP copied to clipboard.');
  } catch(e) {
    log('Clipboard copy failed (maybe insecure context).');
  }
});

createOfferBtn.addEventListener('click', async () => {
  isSender = true;
  await startAsCaller();
});

acceptOfferBtn.addEventListener('click', async () => {
  isSender = false;
  await startAsReceiver();
});

applyRemoteBtn.addEventListener('click', async () => {
  if (!pc) { log('No PeerConnection created yet.'); return; }
  const sdp = remoteSDP.value.trim();
  if (!sdp) { log('Remote SDP is empty.'); return; }
  try {
    const desc = JSON.parse(sdp);
    await pc.setRemoteDescription(desc);
    log('Remote description applied.');
    statusSpan.textContent = 'remote-applied';
  } catch (e) {
    log('Failed to set remote description:', e);
  }
});

// ---- functions ----
function createPeerConnection() {
  const config = { iceServers: [{urls: ['stun:stun.l.google.com:19302']}] };
  pc = new RTCPeerConnection(config);
  pc.onicecandidate = e => {
    if (e.candidate) {
      // ICE candidates will be included automatically in the SDP when complete.
      // For manual signaling we don't exchange candidates separately.
    } else {
      // ICE gathering finished — export local description
      localSDP.value = JSON.stringify(pc.localDescription);
      log('ICE gathering complete. Local SDP ready to copy/send.');
    }
  };
  pc.onconnectionstatechange = () => {
    pcState.textContent = pc.connectionState;
    log('Connection state:', pc.connectionState);
  };
  pc.ondatachannel = ev => {
    log('Data channel received (remote).');
    setupDataChannel(ev.channel);
  };
  return pc;
}

function setupDataChannel(channel) {
  dataChannel = channel;
  dataChannel.binaryType = 'arraybuffer';
  dataChannel.onopen = () => {
    log('DataChannel open. Ready to transfer.');
    statusSpan.textContent = 'connected';
  };
  dataChannel.onclose = () => log('DataChannel closed.');
  dataChannel.onerror = e => log('DataChannel error', e);
  dataChannel.onmessage = async (ev) => {
    // First message might be metadata JSON
    if (typeof ev.data === 'string') {
      try {
        const msg = JSON.parse(ev.data);
        if (msg.type === 'meta') {
          expectedFileSize = msg.size;
          expectedFileName = msg.name;
          receiveBuffer = [];
          receivedSize = 0;
          recvProgress.max = expectedFileSize;
          recvProgress.value = 0;
          recvInfo.textContent = `Receiving "${expectedFileName}" (${expectedFileSize} bytes)`;
          log('Receiving metadata:', msg);
          return;
        }
      } catch(e) {
        // not JSON — ignore
      }
    }
    // binary chunk
    const chunk = ev.data;
    receiveBuffer.push(chunk);
    receivedSize += chunk.byteLength ?? chunk.length ?? 0;
    recvProgress.value = receivedSize;
    recvInfo.textContent = `Received ${(receivedSize/1024|0)} KB / ${(expectedFileSize/1024|0)} KB`;
    // If complete
    if (expectedFileSize && receivedSize >= expectedFileSize) {
      const received = new Blob(receiveBuffer);
      const a = document.createElement('a');
      a.href = URL.createObjectURL(received);
      a.download = expectedFileName || 'download';
      a.textContent = `Click to download ${a.download}`;
      // automatic click:
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      log('File received and download started:', expectedFileName);
      recvInfo.textContent = `Received complete: ${expectedFileName} (${expectedFileSize} bytes)`;
      receiveBuffer = [];
      expectedFileSize = 0;
      expectedFileName = '';
    }
  };
}

async function startAsCaller() {
  reset();
  createPeerConnection();
  // Data channel for sending
  const dc = pc.createDataChannel('file-transfer', {ordered:true});
  setupDataChannel(dc);
  // Create offer
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  statusSpan.textContent = 'offer-created';
  localSDP.value = JSON.stringify(pc.localDescription);
  log('Offer created. Copy local SDP and send to receiver. Receiver will paste their SDP back.');
  // Note: ICE gathering will append candidate info and update localSDP when finished.
}

async function startAsReceiver() {
  reset();
  createPeerConnection();
  statusSpan.textContent = 'waiting-for-offer';
  log('Receiver ready. Paste the sender\'s Offer SDP into "Remote SDP" and click "Apply Remote SDP". After that, create an Answer in your console UI (will be automatic) and paste it back to sender if requested.');
  // To make UX easier: the receiver will create answer automatically after applying remote SDP in applyRemoteBtn handler.
  // We'll add a small listener to auto-create answer when remote desc is set:
  pc.addEventListener('signalingstatechange', async function waitForRemote() {
    try {
      if (pc.remoteDescription && pc.remoteDescription.type === 'offer' && pc.signalingState === 'have-remote-offer') {
        log('Remote offer detected — creating answer...');
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        localSDP.value = JSON.stringify(pc.localDescription);
        log('Answer created. Copy local SDP and send back to sender.');
      }
    } catch (e) { log('Error creating answer:', e); }
  });
}

// Sending file
fileInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  if (!dataChannel || dataChannel.readyState !== 'open') {
    log('DataChannel is not open. Create offer/connect first and wait until connected.');
    return;
  }
  // send metadata first
  const meta = { type:'meta', name: file.name, size: file.size };
  dataChannel.send(JSON.stringify(meta));
  log('Sent metadata:', meta);
  const chunkSize = Math.max(1024, Number(chunkSizeInput.value) || 16384);
  sendProgress.max = file.size;
  sendProgress.value = 0;
  sendInfo.textContent = `Sending "${file.name}" (${file.size} bytes)`;
  const stream = file.stream ? file.stream() : null;
  if (stream && stream.getReader) {
    // use stream API when available (fast & memory efficient)
    const reader = stream.getReader();
    let sent = 0;
    while(true) {
      const {done, value} = await reader.read();
      if (done) break;
      // value is Uint8Array
      // If value is larger than chunkSize, split it:
      let offset = 0;
      while (offset < value.byteLength) {
        const end = Math.min(offset + chunkSize, value.byteLength);
        const slice = value.slice(offset, end);
        dataChannel.send(slice);
        sent += slice.byteLength;
        sendProgress.value = sent;
        sendInfo.textContent = `${(sent/1024|0)} KB / ${(file.size/1024|0)} KB`;
        offset = end;
        // throttle if bufferFull:
        await waitIfBufferFull();
      }
    }
  } else {
    // fallback: File.slice
    let offset = 0;
    const size = file.size;
    while (offset < size) {
      const chunk = file.slice(offset, offset + chunkSize);
      const arrayBuffer = await chunk.arrayBuffer();
      dataChannel.send(arrayBuffer);
      offset += arrayBuffer.byteLength;
      sendProgress.value = offset;
      sendInfo.textContent = `${(offset/1024|0)} KB / ${(file.size/1024|0)} KB`;
      await waitIfBufferFull();
    }
  }
  log('File send complete:', file.name);
  sendInfo.textContent = `Send complete: ${file.name}`;
});

// Helper to wait if DataChannel bufferedAmount is high
function waitIfBufferFull() {
  return new Promise(resolve => {
    const MAX_BUFFER = 16 * 1024 * 1024; // 16MB threshold (heuristic)
    if (!dataChannel) return resolve();
    if (dataChannel.bufferedAmount < MAX_BUFFER) return resolve();
    // otherwise wait until bufferedAmountLow (no event for that, poll)
    const iv = setInterval(() => {
      if (dataChannel.bufferedAmount < MAX_BUFFER) {
        clearInterval(iv);
        resolve();
      }
    }, 50);
  });
}

// initialize
reset();
log('App ready. To send: click "Create Offer" on sender device. Copy local SDP and paste into receiver device -> Apply -> Receiver will create Answer and show local SDP -> Copy that back to sender -> Sender paste it into remote SDP and Apply.');
</script>
</body>
</html>
                     if (peerConnection.iceGatheringState === 'complete') {
                                resolve();
                            }
                        });
                        setTimeout(resolve, 3000);
                    }
                });

                await supabaseClient
                    .from('file_transfers')
                    .update({ answer: JSON.stringify(peerConnection.localDescription) })
                    .eq('code', code);

                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannelReceiver();
                    document.getElementById('receiverConnectionStatus').classList.add('show');
                    showStatus('receiveStatus', '✅ Connected!', 'success');
                };

            } catch (error) {
                console.error('Error:', error);
                showStatus('receiveStatus', '❌ Failed', 'error');
                document.getElementById('connectBtn').disabled = false;
            }
        }

        function setupDataChannelReceiver() {
            const startTime = Date.now();

            dataChannel.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    const message = JSON.parse(event.data);
                    
                    if (message.type === 'metadata') {
                        fileMetadata = message;
                        document.getElementById('receiveProgress').classList.add('show');
                    } else if (message.type === 'complete') {
                        completeFileReceive();
                    }
                } else {
                    receiveBuffer.push(event.data);
                    receivedSize += event.data.byteLength;

                    if (fileMetadata) {
                        const progress = (receivedSize / fileMetadata.fileSize) * 100;
                        document.getElementById('receiveProgressBar').style.width = progress + '%';
                        document.getElementById('receiveProgressBar').textContent = Math.round(progress) + '%';
                        document.getElementById('receiveProgressPercent').textContent = Math.round(progress) + '%';

                        const elapsed = (Date.now() - startTime) / 1000;
                        const speed = receivedSize / elapsed;
                        document.getElementById('receiveSpeed').textContent = '⚡ ' + formatSpeed(speed);
                    }
                }
            };

            dataChannel.onerror = (error) => {
                console.error('Channel error:', error);
                showStatus('receiveStatus', '❌ Error', 'error');
            };
        }

        function completeFileReceive() {
            const blob = new Blob(receiveBuffer, { type: fileMetadata.fileType });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = fileMetadata.fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus('receiveStatus', '✅ Downloaded!', 'success');
            document.getElementById('receiveSpeed').textContent = '✅ Done!';
            document.getElementById('receiverStatusText').textContent = '✅ Complete!';
            
            receiveBuffer = [];
            receivedSize = 0;
            document.getElementById('connectBtn').disabled = false;
        }
    </script>
</body>
</html>
